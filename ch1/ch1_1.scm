#!/usr/bin/guile
!#

;习题1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

;习题1.3
(define (f x y z)
 (cond ((and (> x y) (> y z)) (+ x y))
       ((and (> x y) (> z y)) (+ x z))
       ((and (> y x) (> x z)) (+ x y))
       ((and (> y x) (> z x)) (+ z y))
       ((and (> z x) (> x y)) (+ z x))
       (else (+ z y))))

;习题1.5
; (define (p) (p))
; (define (test x y) (if (= x 0) 0 y))
; (test 0 (p))
;guile使用应用序求值，解释器会挂掉
;因为正则序会先展开所有表达式而不对参数求值
;即展开(test 0 (p))为一串if表达式
;然后返回0
;而应用序会先尝试对test的两个参数求值
;因为(p)无法得到最终值，解释器挂掉

;这里要注意，if本身是先求条件
;然后根据条件去求两个分支中的一个，另一个完全不求值
;但是用test封装后，解释器是在对参数进行应用序求值
;而cond则是先求出所有的分支的结果，然后根据条件返回对应分支的结果
